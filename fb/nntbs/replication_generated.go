// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package nntbs

import (
	"strconv"

	flatbuffers "github.com/google/flatbuffers/go"
)

/*type NumericValueT struct {
	Type NumericValue
	Value interface{}
}

func NumericValuePack(builder *flatbuffers.Builder, t *NumericValueT) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	switch t.Type {
	case NumericValueIntValue:
		return circonus__irondb.IntValuePack(builder, t.Value.(*circonus__irondb.IntValueT))
	case NumericValueUintValue:
		return circonus__irondb.UintValuePack(builder, t.Value.(*circonus__irondb.UintValueT))
	case NumericValueLongValue:
		return circonus__irondb.LongValuePack(builder, t.Value.(*circonus__irondb.LongValueT))
	case NumericValueUlongValue:
		return circonus__irondb.UlongValuePack(builder, t.Value.(*circonus__irondb.UlongValueT))
	case NumericValueDoubleValue:
		return circonus__irondb.DoubleValuePack(builder, t.Value.(*circonus__irondb.DoubleValueT))
	case NumericValueAbsentValue:
		return circonus__irondb.AbsentValuePack(builder, t.Value.(*circonus__irondb.AbsentValueT))
	case NumericValueNullValue:
		return circonus__irondb.NullValuePack(builder, t.Value.(*circonus__irondb.NullValueT))
	}
	return 0
}

func NumericValueUnPack(t NumericValue, table flatbuffers.Table) *NumericValueT {
	switch t {
	case NumericValueIntValue:
		x := IntValue{_tab: table}
		return &circonus__irondb.NumericValueT{ Type: NumericValueIntValue, Value: x.UnPack() }
	case NumericValueUintValue:
		x := UintValue{_tab: table}
		return &circonus__irondb.NumericValueT{ Type: NumericValueUintValue, Value: x.UnPack() }
	case NumericValueLongValue:
		x := LongValue{_tab: table}
		return &circonus__irondb.NumericValueT{ Type: NumericValueLongValue, Value: x.UnPack() }
	case NumericValueUlongValue:
		x := UlongValue{_tab: table}
		return &circonus__irondb.NumericValueT{ Type: NumericValueUlongValue, Value: x.UnPack() }
	case NumericValueDoubleValue:
		x := DoubleValue{_tab: table}
		return &circonus__irondb.NumericValueT{ Type: NumericValueDoubleValue, Value: x.UnPack() }
	case NumericValueAbsentValue:
		x := AbsentValue{_tab: table}
		return &circonus__irondb.NumericValueT{ Type: NumericValueAbsentValue, Value: x.UnPack() }
	case NumericValueNullValue:
		x := NullValue{_tab: table}
		return &circonus__irondb.NumericValueT{ Type: NumericValueNullValue, Value: x.UnPack() }
	}
	return nil
}*/

type NumericValue byte

const (
	NumericValueNONE        NumericValue = 0
	NumericValueIntValue    NumericValue = 1
	NumericValueUintValue   NumericValue = 2
	NumericValueLongValue   NumericValue = 3
	NumericValueUlongValue  NumericValue = 4
	NumericValueDoubleValue NumericValue = 5
	NumericValueAbsentValue NumericValue = 6
	NumericValueNullValue   NumericValue = 7
)

var EnumNamesNumericValue = map[NumericValue]string{
	NumericValueNONE:        "NONE",
	NumericValueIntValue:    "IntValue",
	NumericValueUintValue:   "UintValue",
	NumericValueLongValue:   "LongValue",
	NumericValueUlongValue:  "UlongValue",
	NumericValueDoubleValue: "DoubleValue",
	NumericValueAbsentValue: "AbsentValue",
	NumericValueNullValue:   "NullValue",
}

var EnumValuesNumericValue = map[string]NumericValue{
	"NONE":        NumericValueNONE,
	"IntValue":    NumericValueIntValue,
	"UintValue":   NumericValueUintValue,
	"LongValue":   NumericValueLongValue,
	"UlongValue":  NumericValueUlongValue,
	"DoubleValue": NumericValueDoubleValue,
	"AbsentValue": NumericValueAbsentValue,
	"NullValue":   NumericValueNullValue,
}

func (v NumericValue) String() string {
	if s, ok := EnumNamesNumericValue[v]; ok {
		return s
	}
	return "NumericValue(" + strconv.FormatInt(int64(v), 10) + ")"
}

/*type ReplicationValueT struct {
	Type ReplicationValue
	Value interface{}
}

func ReplicationValuePack(builder *flatbuffers.Builder, t *ReplicationValueT) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	switch t.Type {
	case ReplicationValueNNT_V2:
		return NNT_V2Pack(builder, t.Value.(*NNT_V2T))
	case ReplicationValueText:
		return TextPack(builder, t.Value.(*TextT))
	case ReplicationValueHistogram:
		return HistogramPack(builder, t.Value.(*HistogramT))
	case ReplicationValueRawNumeric:
		return RawNumericPack(builder, t.Value.(*RawNumericT))
	case ReplicationValueLogMsg:
		return LogMsgPack(builder, t.Value.(*LogMsgT))
	case ReplicationValueLoadLuaMsg:
		return LoadLuaMsgPack(builder, t.Value.(*LoadLuaMsgT))
	case ReplicationValueDeleteMsg:
		return DeleteMsgPack(builder, t.Value.(*DeleteMsgT))
	case ReplicationValueSurrogatePut:
		return SurrogatePutPack(builder, t.Value.(*SurrogatePutT))
	case ReplicationValueActivityRebuild:
		return ActivityRebuildPack(builder, t.Value.(*ActivityRebuildT))
	case ReplicationValueSetCrdtAlter:
		return SetCrdtAlterPack(builder, t.Value.(*SetCrdtAlterT))
	case ReplicationValueSetCrdtMergeRequest:
		return SetCrdtMergeRequestPack(builder, t.Value.(*SetCrdtMergeRequestT))
	}
	return 0
}

func ReplicationValueUnPack(t ReplicationValue, table flatbuffers.Table) *ReplicationValueT {
	switch t {
	case ReplicationValueNNT_V2:
		x := NNT_V2{_tab: table}
		return &ReplicationValueT{ Type: ReplicationValueNNT_V2, Value: x.UnPack() }
	case ReplicationValueText:
		x := Text{_tab: table}
		return &ReplicationValueT{ Type: ReplicationValueText, Value: x.UnPack() }
	case ReplicationValueHistogram:
		x := Histogram{_tab: table}
		return &ReplicationValueT{ Type: ReplicationValueHistogram, Value: x.UnPack() }
	case ReplicationValueRawNumeric:
		x := RawNumeric{_tab: table}
		return &ReplicationValueT{ Type: ReplicationValueRawNumeric, Value: x.UnPack() }
	case ReplicationValueLogMsg:
		x := LogMsg{_tab: table}
		return &ReplicationValueT{ Type: ReplicationValueLogMsg, Value: x.UnPack() }
	case ReplicationValueLoadLuaMsg:
		x := LoadLuaMsg{_tab: table}
		return &ReplicationValueT{ Type: ReplicationValueLoadLuaMsg, Value: x.UnPack() }
	case ReplicationValueDeleteMsg:
		x := DeleteMsg{_tab: table}
		return &ReplicationValueT{ Type: ReplicationValueDeleteMsg, Value: x.UnPack() }
	case ReplicationValueSurrogatePut:
		x := SurrogatePut{_tab: table}
		return &ReplicationValueT{ Type: ReplicationValueSurrogatePut, Value: x.UnPack() }
	case ReplicationValueActivityRebuild:
		x := ActivityRebuild{_tab: table}
		return &ReplicationValueT{ Type: ReplicationValueActivityRebuild, Value: x.UnPack() }
	case ReplicationValueSetCrdtAlter:
		x := SetCrdtAlter{_tab: table}
		return &ReplicationValueT{ Type: ReplicationValueSetCrdtAlter, Value: x.UnPack() }
	case ReplicationValueSetCrdtMergeRequest:
		x := SetCrdtMergeRequest{_tab: table}
		return &ReplicationValueT{ Type: ReplicationValueSetCrdtMergeRequest, Value: x.UnPack() }
	}
	return nil
}*/

type ReplicationValue byte

const (
	ReplicationValueNONE                ReplicationValue = 0
	ReplicationValueNNT_V2              ReplicationValue = 1
	ReplicationValueText                ReplicationValue = 2
	ReplicationValueHistogram           ReplicationValue = 3
	ReplicationValueRawNumeric          ReplicationValue = 4
	ReplicationValueLogMsg              ReplicationValue = 5
	ReplicationValueLoadLuaMsg          ReplicationValue = 6
	ReplicationValueDeleteMsg           ReplicationValue = 7
	ReplicationValueSurrogatePut        ReplicationValue = 8
	ReplicationValueActivityRebuild     ReplicationValue = 9
	ReplicationValueSetCrdtAlter        ReplicationValue = 10
	ReplicationValueSetCrdtMergeRequest ReplicationValue = 11
)

var EnumNamesReplicationValue = map[ReplicationValue]string{
	ReplicationValueNONE:                "NONE",
	ReplicationValueNNT_V2:              "NNT_V2",
	ReplicationValueText:                "Text",
	ReplicationValueHistogram:           "Histogram",
	ReplicationValueRawNumeric:          "RawNumeric",
	ReplicationValueLogMsg:              "LogMsg",
	ReplicationValueLoadLuaMsg:          "LoadLuaMsg",
	ReplicationValueDeleteMsg:           "DeleteMsg",
	ReplicationValueSurrogatePut:        "SurrogatePut",
	ReplicationValueActivityRebuild:     "ActivityRebuild",
	ReplicationValueSetCrdtAlter:        "SetCrdtAlter",
	ReplicationValueSetCrdtMergeRequest: "SetCrdtMergeRequest",
}

var EnumValuesReplicationValue = map[string]ReplicationValue{
	"NONE":                ReplicationValueNONE,
	"NNT_V2":              ReplicationValueNNT_V2,
	"Text":                ReplicationValueText,
	"Histogram":           ReplicationValueHistogram,
	"RawNumeric":          ReplicationValueRawNumeric,
	"LogMsg":              ReplicationValueLogMsg,
	"LoadLuaMsg":          ReplicationValueLoadLuaMsg,
	"DeleteMsg":           ReplicationValueDeleteMsg,
	"SurrogatePut":        ReplicationValueSurrogatePut,
	"ActivityRebuild":     ReplicationValueActivityRebuild,
	"SetCrdtAlter":        ReplicationValueSetCrdtAlter,
	"SetCrdtMergeRequest": ReplicationValueSetCrdtMergeRequest,
}

func (v ReplicationValue) String() string {
	if s, ok := EnumNamesReplicationValue[v]; ok {
		return s
	}
	return "ReplicationValue(" + strconv.FormatInt(int64(v), 10) + ")"
}

type IntValueT struct {
	V int32
}

func IntValuePack(builder *flatbuffers.Builder, t *IntValueT) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	IntValueStart(builder)
	IntValueAddV(builder, t.V)
	return IntValueEnd(builder)
}

func (rcv *IntValue) UnPack() *IntValueT {
	if rcv == nil {
		return nil
	}
	t := &IntValueT{}
	t.V = rcv.V()
	return t
}

type IntValue struct {
	_tab flatbuffers.Table
}

func GetRootAsIntValue(buf []byte, offset flatbuffers.UOffsetT) *IntValue {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &IntValue{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *IntValue) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *IntValue) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *IntValue) V() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *IntValue) MutateV(n int32) bool {
	return rcv._tab.MutateInt32Slot(4, n)
}

func IntValueStart(builder *flatbuffers.Builder) {
	builder.StartObject(1)
}
func IntValueAddV(builder *flatbuffers.Builder, v int32) {
	builder.PrependInt32Slot(0, v, 0)
}
func IntValueEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type UintValueT struct {
	V uint32
}

func UintValuePack(builder *flatbuffers.Builder, t *UintValueT) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	UintValueStart(builder)
	UintValueAddV(builder, t.V)
	return UintValueEnd(builder)
}

func (rcv *UintValue) UnPack() *UintValueT {
	if rcv == nil {
		return nil
	}
	t := &UintValueT{}
	t.V = rcv.V()
	return t
}

type UintValue struct {
	_tab flatbuffers.Table
}

func GetRootAsUintValue(buf []byte, offset flatbuffers.UOffsetT) *UintValue {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &UintValue{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *UintValue) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *UintValue) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *UintValue) V() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *UintValue) MutateV(n uint32) bool {
	return rcv._tab.MutateUint32Slot(4, n)
}

func UintValueStart(builder *flatbuffers.Builder) {
	builder.StartObject(1)
}
func UintValueAddV(builder *flatbuffers.Builder, v uint32) {
	builder.PrependUint32Slot(0, v, 0)
}
func UintValueEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type LongValueT struct {
	V int64
}

func LongValuePack(builder *flatbuffers.Builder, t *LongValueT) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	LongValueStart(builder)
	LongValueAddV(builder, t.V)
	return LongValueEnd(builder)
}

func (rcv *LongValue) UnPack() *LongValueT {
	if rcv == nil {
		return nil
	}
	t := &LongValueT{}
	t.V = rcv.V()
	return t
}

type LongValue struct {
	_tab flatbuffers.Table
}

func GetRootAsLongValue(buf []byte, offset flatbuffers.UOffsetT) *LongValue {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &LongValue{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *LongValue) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *LongValue) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *LongValue) V() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *LongValue) MutateV(n int64) bool {
	return rcv._tab.MutateInt64Slot(4, n)
}

func LongValueStart(builder *flatbuffers.Builder) {
	builder.StartObject(1)
}
func LongValueAddV(builder *flatbuffers.Builder, v int64) {
	builder.PrependInt64Slot(0, v, 0)
}
func LongValueEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type UlongValueT struct {
	V uint64
}

func UlongValuePack(builder *flatbuffers.Builder, t *UlongValueT) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	UlongValueStart(builder)
	UlongValueAddV(builder, t.V)
	return UlongValueEnd(builder)
}

func (rcv *UlongValue) UnPack() *UlongValueT {
	if rcv == nil {
		return nil
	}
	t := &UlongValueT{}
	t.V = rcv.V()
	return t
}

type UlongValue struct {
	_tab flatbuffers.Table
}

func GetRootAsUlongValue(buf []byte, offset flatbuffers.UOffsetT) *UlongValue {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &UlongValue{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *UlongValue) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *UlongValue) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *UlongValue) V() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *UlongValue) MutateV(n uint64) bool {
	return rcv._tab.MutateUint64Slot(4, n)
}

func UlongValueStart(builder *flatbuffers.Builder) {
	builder.StartObject(1)
}
func UlongValueAddV(builder *flatbuffers.Builder, v uint64) {
	builder.PrependUint64Slot(0, v, 0)
}
func UlongValueEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type DoubleValueT struct {
	V float64
}

func DoubleValuePack(builder *flatbuffers.Builder, t *DoubleValueT) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	DoubleValueStart(builder)
	DoubleValueAddV(builder, t.V)
	return DoubleValueEnd(builder)
}

func (rcv *DoubleValue) UnPack() *DoubleValueT {
	if rcv == nil {
		return nil
	}
	t := &DoubleValueT{}
	t.V = rcv.V()
	return t
}

type DoubleValue struct {
	_tab flatbuffers.Table
}

func GetRootAsDoubleValue(buf []byte, offset flatbuffers.UOffsetT) *DoubleValue {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &DoubleValue{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *DoubleValue) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *DoubleValue) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *DoubleValue) V() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *DoubleValue) MutateV(n float64) bool {
	return rcv._tab.MutateFloat64Slot(4, n)
}

func DoubleValueStart(builder *flatbuffers.Builder) {
	builder.StartObject(1)
}
func DoubleValueAddV(builder *flatbuffers.Builder, v float64) {
	builder.PrependFloat64Slot(0, v, 0.0)
}
func DoubleValueEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type NullValueT struct {
	V        bool
	OrigType int32
}

func NullValuePack(builder *flatbuffers.Builder, t *NullValueT) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	NullValueStart(builder)
	NullValueAddV(builder, t.V)
	NullValueAddOrigType(builder, t.OrigType)
	return NullValueEnd(builder)
}

func (rcv *NullValue) UnPack() *NullValueT {
	if rcv == nil {
		return nil
	}
	t := &NullValueT{}
	t.V = rcv.V()
	t.OrigType = rcv.OrigType()
	return t
}

type NullValue struct {
	_tab flatbuffers.Table
}

func GetRootAsNullValue(buf []byte, offset flatbuffers.UOffsetT) *NullValue {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &NullValue{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *NullValue) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *NullValue) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *NullValue) V() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

func (rcv *NullValue) MutateV(n bool) bool {
	return rcv._tab.MutateBoolSlot(4, n)
}

func (rcv *NullValue) OrigType() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *NullValue) MutateOrigType(n int32) bool {
	return rcv._tab.MutateInt32Slot(6, n)
}

func NullValueStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func NullValueAddV(builder *flatbuffers.Builder, v bool) {
	builder.PrependBoolSlot(0, v, false)
}
func NullValueAddOrigType(builder *flatbuffers.Builder, origType int32) {
	builder.PrependInt32Slot(1, origType, 0)
}
func NullValueEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type AbsentValueT struct {
	V bool
}

func AbsentValuePack(builder *flatbuffers.Builder, t *AbsentValueT) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	AbsentValueStart(builder)
	AbsentValueAddV(builder, t.V)
	return AbsentValueEnd(builder)
}

func (rcv *AbsentValue) UnPack() *AbsentValueT {
	if rcv == nil {
		return nil
	}
	t := &AbsentValueT{}
	t.V = rcv.V()
	return t
}

type AbsentValue struct {
	_tab flatbuffers.Table
}

func GetRootAsAbsentValue(buf []byte, offset flatbuffers.UOffsetT) *AbsentValue {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &AbsentValue{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *AbsentValue) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *AbsentValue) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *AbsentValue) V() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

func (rcv *AbsentValue) MutateV(n bool) bool {
	return rcv._tab.MutateBoolSlot(4, n)
}

func AbsentValueStart(builder *flatbuffers.Builder) {
	builder.StartObject(1)
}
func AbsentValueAddV(builder *flatbuffers.Builder, v bool) {
	builder.PrependBoolSlot(0, v, false)
}
func AbsentValueEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type MetricLocatorT struct {
	CheckUuid  []byte
	MetricName string
	StreamTags []string
}

func MetricLocatorPack(builder *flatbuffers.Builder, t *MetricLocatorT) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	checkUuidOffset := flatbuffers.UOffsetT(0)
	if t.CheckUuid != nil {
		checkUuidOffset = builder.CreateByteString(t.CheckUuid)
	}
	metricNameOffset := builder.CreateString(t.MetricName)
	streamTagsOffset := flatbuffers.UOffsetT(0)
	if t.StreamTags != nil {
		streamTagsLength := len(t.StreamTags)
		streamTagsOffsets := make([]flatbuffers.UOffsetT, streamTagsLength)
		for j := 0; j < streamTagsLength; j++ {
			streamTagsOffsets[j] = builder.CreateString(t.StreamTags[j])
		}
		MetricLocatorStartStreamTagsVector(builder, streamTagsLength)
		for j := streamTagsLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(streamTagsOffsets[j])
		}
		streamTagsOffset = builder.EndVector(streamTagsLength)
	}
	MetricLocatorStart(builder)
	MetricLocatorAddCheckUuid(builder, checkUuidOffset)
	MetricLocatorAddMetricName(builder, metricNameOffset)
	MetricLocatorAddStreamTags(builder, streamTagsOffset)
	return MetricLocatorEnd(builder)
}

func (rcv *MetricLocator) UnPack() *MetricLocatorT {
	if rcv == nil {
		return nil
	}
	t := &MetricLocatorT{}
	t.CheckUuid = rcv.CheckUuidBytes()
	t.MetricName = string(rcv.MetricName())
	streamTagsLength := rcv.StreamTagsLength()
	t.StreamTags = make([]string, streamTagsLength)
	for j := 0; j < streamTagsLength; j++ {
		t.StreamTags[j] = string(rcv.StreamTags(j))
	}
	return t
}

type MetricLocator struct {
	_tab flatbuffers.Table
}

func GetRootAsMetricLocator(buf []byte, offset flatbuffers.UOffsetT) *MetricLocator {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &MetricLocator{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *MetricLocator) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *MetricLocator) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *MetricLocator) CheckUuid(j int) byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetByte(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *MetricLocator) CheckUuidLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *MetricLocator) CheckUuidBytes() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *MetricLocator) MutateCheckUuid(j int, n byte) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateByte(a+flatbuffers.UOffsetT(j*1), n)
	}
	return false
}

func (rcv *MetricLocator) MetricName() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *MetricLocator) StreamTags(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *MetricLocator) StreamTagsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func MetricLocatorStart(builder *flatbuffers.Builder) {
	builder.StartObject(3)
}
func MetricLocatorAddCheckUuid(builder *flatbuffers.Builder, checkUuid flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(checkUuid), 0)
}
func MetricLocatorStartCheckUuidVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func MetricLocatorAddMetricName(builder *flatbuffers.Builder, metricName flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(metricName), 0)
}
func MetricLocatorAddStreamTags(builder *flatbuffers.Builder, streamTags flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(streamTags), 0)
}
func MetricLocatorStartStreamTagsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func MetricLocatorEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type MetricInfoT struct {
	MetricLocator *MetricLocatorT
	AccountId     int32
	CheckName     string
	CheckCategory int32
}

func MetricInfoPack(builder *flatbuffers.Builder, t *MetricInfoT) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	metricLocatorOffset := MetricLocatorPack(builder, t.MetricLocator)
	checkNameOffset := builder.CreateString(t.CheckName)
	MetricInfoStart(builder)
	MetricInfoAddMetricLocator(builder, metricLocatorOffset)
	MetricInfoAddAccountId(builder, t.AccountId)
	MetricInfoAddCheckName(builder, checkNameOffset)
	MetricInfoAddCheckCategory(builder, t.CheckCategory)
	return MetricInfoEnd(builder)
}

func (rcv *MetricInfo) UnPack() *MetricInfoT {
	if rcv == nil {
		return nil
	}
	t := &MetricInfoT{}
	t.MetricLocator = rcv.MetricLocator(nil).UnPack()
	t.AccountId = rcv.AccountId()
	t.CheckName = string(rcv.CheckName())
	t.CheckCategory = rcv.CheckCategory()
	return t
}

type MetricInfo struct {
	_tab flatbuffers.Table
}

func GetRootAsMetricInfo(buf []byte, offset flatbuffers.UOffsetT) *MetricInfo {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &MetricInfo{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *MetricInfo) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *MetricInfo) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *MetricInfo) MetricLocator(obj *MetricLocator) *MetricLocator {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(MetricLocator)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *MetricInfo) AccountId() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *MetricInfo) MutateAccountId(n int32) bool {
	return rcv._tab.MutateInt32Slot(6, n)
}

func (rcv *MetricInfo) CheckName() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *MetricInfo) CheckCategory() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *MetricInfo) MutateCheckCategory(n int32) bool {
	return rcv._tab.MutateInt32Slot(10, n)
}

func MetricInfoStart(builder *flatbuffers.Builder) {
	builder.StartObject(4)
}
func MetricInfoAddMetricLocator(builder *flatbuffers.Builder, metricLocator flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(metricLocator), 0)
}
func MetricInfoAddAccountId(builder *flatbuffers.Builder, accountId int32) {
	builder.PrependInt32Slot(1, accountId, 0)
}
func MetricInfoAddCheckName(builder *flatbuffers.Builder, checkName flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(checkName), 0)
}
func MetricInfoAddCheckCategory(builder *flatbuffers.Builder, checkCategory int32) {
	builder.PrependInt32Slot(3, checkCategory, 0)
}
func MetricInfoEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type NNT_V2T struct {
	MetricLocator    *MetricLocatorT
	Period           uint64
	Count            uint16
	Stddev           float32
	Value            *NumericValueT
	Derivative       float32
	DerivativeStddev float32
	Counter          float32
	CounterStddev    float32
	MetricInfo       *MetricInfoT
}

func NNT_V2Pack(builder *flatbuffers.Builder, t *NNT_V2T) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	metricLocatorOffset := MetricLocatorPack(builder, t.MetricLocator)
	valueOffset := NumericValuePack(builder, t.Value)

	metricInfoOffset := MetricInfoPack(builder, t.MetricInfo)
	NNT_V2Start(builder)
	NNT_V2AddMetricLocator(builder, metricLocatorOffset)
	NNT_V2AddPeriod(builder, t.Period)
	NNT_V2AddCount(builder, t.Count)
	NNT_V2AddStddev(builder, t.Stddev)
	if t.Value != nil {
		NNT_V2AddValueType(builder, t.Value.Type)
	}
	NNT_V2AddValue(builder, valueOffset)
	NNT_V2AddDerivative(builder, t.Derivative)
	NNT_V2AddDerivativeStddev(builder, t.DerivativeStddev)
	NNT_V2AddCounter(builder, t.Counter)
	NNT_V2AddCounterStddev(builder, t.CounterStddev)
	NNT_V2AddMetricInfo(builder, metricInfoOffset)
	return NNT_V2End(builder)
}

func (rcv *NNT_V2) UnPack() *NNT_V2T {
	if rcv == nil {
		return nil
	}
	t := &NNT_V2T{}
	t.MetricLocator = rcv.MetricLocator(nil).UnPack()
	t.Period = rcv.Period()
	t.Count = rcv.Count()
	t.Stddev = rcv.Stddev()
	valueTable := flatbuffers.Table{}
	if rcv.Value(&valueTable) {
		t.Value = NumericValueUnPack(rcv.ValueType(), valueTable)
	}
	t.Derivative = rcv.Derivative()
	t.DerivativeStddev = rcv.DerivativeStddev()
	t.Counter = rcv.Counter()
	t.CounterStddev = rcv.CounterStddev()
	t.MetricInfo = rcv.MetricInfo(nil).UnPack()
	return t
}

type NNT_V2 struct {
	_tab flatbuffers.Table
}

func GetRootAsNNT_V2(buf []byte, offset flatbuffers.UOffsetT) *NNT_V2 {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &NNT_V2{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *NNT_V2) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *NNT_V2) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *NNT_V2) MetricLocator(obj *MetricLocator) *MetricLocator {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(MetricLocator)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *NNT_V2) Period() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *NNT_V2) MutatePeriod(n uint64) bool {
	return rcv._tab.MutateUint64Slot(6, n)
}

func (rcv *NNT_V2) Count() uint16 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetUint16(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *NNT_V2) MutateCount(n uint16) bool {
	return rcv._tab.MutateUint16Slot(8, n)
}

func (rcv *NNT_V2) Stddev() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *NNT_V2) MutateStddev(n float32) bool {
	return rcv._tab.MutateFloat32Slot(10, n)
}

func (rcv *NNT_V2) ValueType() NumericValue {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return NumericValue(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *NNT_V2) MutateValueType(n NumericValue) bool {
	return rcv._tab.MutateByteSlot(12, byte(n))
}

func (rcv *NNT_V2) Value(obj *flatbuffers.Table) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		rcv._tab.Union(obj, o)
		return true
	}
	return false
}

func (rcv *NNT_V2) Derivative() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *NNT_V2) MutateDerivative(n float32) bool {
	return rcv._tab.MutateFloat32Slot(16, n)
}

func (rcv *NNT_V2) DerivativeStddev() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *NNT_V2) MutateDerivativeStddev(n float32) bool {
	return rcv._tab.MutateFloat32Slot(18, n)
}

func (rcv *NNT_V2) Counter() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *NNT_V2) MutateCounter(n float32) bool {
	return rcv._tab.MutateFloat32Slot(20, n)
}

func (rcv *NNT_V2) CounterStddev() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *NNT_V2) MutateCounterStddev(n float32) bool {
	return rcv._tab.MutateFloat32Slot(22, n)
}

func (rcv *NNT_V2) MetricInfo(obj *MetricInfo) *MetricInfo {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(MetricInfo)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func NNT_V2Start(builder *flatbuffers.Builder) {
	builder.StartObject(11)
}
func NNT_V2AddMetricLocator(builder *flatbuffers.Builder, metricLocator flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(metricLocator), 0)
}
func NNT_V2AddPeriod(builder *flatbuffers.Builder, period uint64) {
	builder.PrependUint64Slot(1, period, 0)
}
func NNT_V2AddCount(builder *flatbuffers.Builder, count uint16) {
	builder.PrependUint16Slot(2, count, 0)
}
func NNT_V2AddStddev(builder *flatbuffers.Builder, stddev float32) {
	builder.PrependFloat32Slot(3, stddev, 0.0)
}
func NNT_V2AddValueType(builder *flatbuffers.Builder, valueType NumericValue) {
	builder.PrependByteSlot(4, byte(valueType), 0)
}
func NNT_V2AddValue(builder *flatbuffers.Builder, value flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(value), 0)
}
func NNT_V2AddDerivative(builder *flatbuffers.Builder, derivative float32) {
	builder.PrependFloat32Slot(6, derivative, 0.0)
}
func NNT_V2AddDerivativeStddev(builder *flatbuffers.Builder, derivativeStddev float32) {
	builder.PrependFloat32Slot(7, derivativeStddev, 0.0)
}
func NNT_V2AddCounter(builder *flatbuffers.Builder, counter float32) {
	builder.PrependFloat32Slot(8, counter, 0.0)
}
func NNT_V2AddCounterStddev(builder *flatbuffers.Builder, counterStddev float32) {
	builder.PrependFloat32Slot(9, counterStddev, 0.0)
}
func NNT_V2AddMetricInfo(builder *flatbuffers.Builder, metricInfo flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(10, flatbuffers.UOffsetT(metricInfo), 0)
}
func NNT_V2End(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type TextT struct {
	MetricInfo *MetricInfoT
	CheckName  string
	Value      string
}

func TextPack(builder *flatbuffers.Builder, t *TextT) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	metricInfoOffset := MetricInfoPack(builder, t.MetricInfo)
	checkNameOffset := builder.CreateString(t.CheckName)
	valueOffset := builder.CreateString(t.Value)
	TextStart(builder)
	TextAddMetricInfo(builder, metricInfoOffset)
	TextAddCheckName(builder, checkNameOffset)
	TextAddValue(builder, valueOffset)
	return TextEnd(builder)
}

func (rcv *Text) UnPack() *TextT {
	if rcv == nil {
		return nil
	}
	t := &TextT{}
	t.MetricInfo = rcv.MetricInfo(nil).UnPack()
	t.CheckName = string(rcv.CheckName())
	t.Value = string(rcv.Value())
	return t
}

type Text struct {
	_tab flatbuffers.Table
}

func GetRootAsText(buf []byte, offset flatbuffers.UOffsetT) *Text {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Text{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Text) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Text) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Text) MetricInfo(obj *MetricInfo) *MetricInfo {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(MetricInfo)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *Text) CheckName() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Text) Value() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func TextStart(builder *flatbuffers.Builder) {
	builder.StartObject(3)
}
func TextAddMetricInfo(builder *flatbuffers.Builder, metricInfo flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(metricInfo), 0)
}
func TextAddCheckName(builder *flatbuffers.Builder, checkName flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(checkName), 0)
}
func TextAddValue(builder *flatbuffers.Builder, value flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(value), 0)
}
func TextEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type HistogramBucketT struct {
	Val   int8
	Exp   int8
	Count uint64
}

func HistogramBucketPack(builder *flatbuffers.Builder, t *HistogramBucketT) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	HistogramBucketStart(builder)
	HistogramBucketAddVal(builder, t.Val)
	HistogramBucketAddExp(builder, t.Exp)
	HistogramBucketAddCount(builder, t.Count)
	return HistogramBucketEnd(builder)
}

func (rcv *HistogramBucket) UnPack() *HistogramBucketT {
	if rcv == nil {
		return nil
	}
	t := &HistogramBucketT{}
	t.Val = rcv.Val()
	t.Exp = rcv.Exp()
	t.Count = rcv.Count()
	return t
}

type HistogramBucket struct {
	_tab flatbuffers.Table
}

func GetRootAsHistogramBucket(buf []byte, offset flatbuffers.UOffsetT) *HistogramBucket {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &HistogramBucket{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *HistogramBucket) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *HistogramBucket) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *HistogramBucket) Val() int8 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetInt8(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *HistogramBucket) MutateVal(n int8) bool {
	return rcv._tab.MutateInt8Slot(4, n)
}

func (rcv *HistogramBucket) Exp() int8 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetInt8(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *HistogramBucket) MutateExp(n int8) bool {
	return rcv._tab.MutateInt8Slot(6, n)
}

func (rcv *HistogramBucket) Count() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *HistogramBucket) MutateCount(n uint64) bool {
	return rcv._tab.MutateUint64Slot(8, n)
}

func HistogramBucketStart(builder *flatbuffers.Builder) {
	builder.StartObject(3)
}
func HistogramBucketAddVal(builder *flatbuffers.Builder, val int8) {
	builder.PrependInt8Slot(0, val, 0)
}
func HistogramBucketAddExp(builder *flatbuffers.Builder, exp int8) {
	builder.PrependInt8Slot(1, exp, 0)
}
func HistogramBucketAddCount(builder *flatbuffers.Builder, count uint64) {
	builder.PrependUint64Slot(2, count, 0)
}
func HistogramBucketEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type HistogramT struct {
	MetricInfo *MetricInfoT
	Buckets    []*HistogramBucketT
}

func HistogramPack(builder *flatbuffers.Builder, t *HistogramT) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	metricInfoOffset := MetricInfoPack(builder, t.MetricInfo)
	bucketsOffset := flatbuffers.UOffsetT(0)
	if t.Buckets != nil {
		bucketsLength := len(t.Buckets)
		bucketsOffsets := make([]flatbuffers.UOffsetT, bucketsLength)
		for j := 0; j < bucketsLength; j++ {
			bucketsOffsets[j] = HistogramBucketPack(builder, t.Buckets[j])
		}
		HistogramStartBucketsVector(builder, bucketsLength)
		for j := bucketsLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(bucketsOffsets[j])
		}
		bucketsOffset = builder.EndVector(bucketsLength)
	}
	HistogramStart(builder)
	HistogramAddMetricInfo(builder, metricInfoOffset)
	HistogramAddBuckets(builder, bucketsOffset)
	return HistogramEnd(builder)
}

func (rcv *Histogram) UnPack() *HistogramT {
	if rcv == nil {
		return nil
	}
	t := &HistogramT{}
	t.MetricInfo = rcv.MetricInfo(nil).UnPack()
	bucketsLength := rcv.BucketsLength()
	t.Buckets = make([]*HistogramBucketT, bucketsLength)
	for j := 0; j < bucketsLength; j++ {
		x := HistogramBucket{}
		rcv.Buckets(&x, j)
		t.Buckets[j] = x.UnPack()
	}
	return t
}

type Histogram struct {
	_tab flatbuffers.Table
}

func GetRootAsHistogram(buf []byte, offset flatbuffers.UOffsetT) *Histogram {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Histogram{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Histogram) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Histogram) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Histogram) MetricInfo(obj *MetricInfo) *MetricInfo {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(MetricInfo)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *Histogram) Buckets(obj *HistogramBucket, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Histogram) BucketsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func HistogramStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func HistogramAddMetricInfo(builder *flatbuffers.Builder, metricInfo flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(metricInfo), 0)
}
func HistogramAddBuckets(builder *flatbuffers.Builder, buckets flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(buckets), 0)
}
func HistogramStartBucketsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func HistogramEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type RawNumericT struct {
	MetricInfo *MetricInfoT
	Value      *NumericValueT
	Generation int16
}

func RawNumericPack(builder *flatbuffers.Builder, t *RawNumericT) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	metricInfoOffset := MetricInfoPack(builder, t.MetricInfo)
	valueOffset := NumericValuePack(builder, t.Value)

	RawNumericStart(builder)
	RawNumericAddMetricInfo(builder, metricInfoOffset)
	if t.Value != nil {
		RawNumericAddValueType(builder, t.Value.Type)
	}
	RawNumericAddValue(builder, valueOffset)
	RawNumericAddGeneration(builder, t.Generation)
	return RawNumericEnd(builder)
}

func (rcv *RawNumeric) UnPack() *RawNumericT {
	if rcv == nil {
		return nil
	}
	t := &RawNumericT{}
	t.MetricInfo = rcv.MetricInfo(nil).UnPack()
	valueTable := flatbuffers.Table{}
	if rcv.Value(&valueTable) {
		t.Value = NumericValueUnPack(rcv.ValueType(), valueTable)
	}
	t.Generation = rcv.Generation()
	return t
}

type RawNumeric struct {
	_tab flatbuffers.Table
}

func GetRootAsRawNumeric(buf []byte, offset flatbuffers.UOffsetT) *RawNumeric {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &RawNumeric{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *RawNumeric) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *RawNumeric) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *RawNumeric) MetricInfo(obj *MetricInfo) *MetricInfo {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(MetricInfo)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *RawNumeric) ValueType() NumericValue {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return NumericValue(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *RawNumeric) MutateValueType(n NumericValue) bool {
	return rcv._tab.MutateByteSlot(6, byte(n))
}

func (rcv *RawNumeric) Value(obj *flatbuffers.Table) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		rcv._tab.Union(obj, o)
		return true
	}
	return false
}

func (rcv *RawNumeric) Generation() int16 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.GetInt16(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *RawNumeric) MutateGeneration(n int16) bool {
	return rcv._tab.MutateInt16Slot(10, n)
}

func RawNumericStart(builder *flatbuffers.Builder) {
	builder.StartObject(4)
}
func RawNumericAddMetricInfo(builder *flatbuffers.Builder, metricInfo flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(metricInfo), 0)
}
func RawNumericAddValueType(builder *flatbuffers.Builder, valueType NumericValue) {
	builder.PrependByteSlot(1, byte(valueType), 0)
}
func RawNumericAddValue(builder *flatbuffers.Builder, value flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(value), 0)
}
func RawNumericAddGeneration(builder *flatbuffers.Builder, generation int16) {
	builder.PrependInt16Slot(3, generation, 0)
}
func RawNumericEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type LogMsgT struct {
	TimevalSecs  uint64
	TimevalUsecs uint64
	Uuid         []byte
	LogMsg       string
}

func LogMsgPack(builder *flatbuffers.Builder, t *LogMsgT) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	uuidOffset := flatbuffers.UOffsetT(0)
	if t.Uuid != nil {
		uuidOffset = builder.CreateByteString(t.Uuid)
	}
	logMsgOffset := builder.CreateString(t.LogMsg)
	LogMsgStart(builder)
	LogMsgAddTimevalSecs(builder, t.TimevalSecs)
	LogMsgAddTimevalUsecs(builder, t.TimevalUsecs)
	LogMsgAddUuid(builder, uuidOffset)
	LogMsgAddLogMsg(builder, logMsgOffset)
	return LogMsgEnd(builder)
}

func (rcv *LogMsg) UnPack() *LogMsgT {
	if rcv == nil {
		return nil
	}
	t := &LogMsgT{}
	t.TimevalSecs = rcv.TimevalSecs()
	t.TimevalUsecs = rcv.TimevalUsecs()
	t.Uuid = rcv.UuidBytes()
	t.LogMsg = string(rcv.LogMsg())
	return t
}

type LogMsg struct {
	_tab flatbuffers.Table
}

func GetRootAsLogMsg(buf []byte, offset flatbuffers.UOffsetT) *LogMsg {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &LogMsg{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *LogMsg) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *LogMsg) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *LogMsg) TimevalSecs() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *LogMsg) MutateTimevalSecs(n uint64) bool {
	return rcv._tab.MutateUint64Slot(4, n)
}

func (rcv *LogMsg) TimevalUsecs() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *LogMsg) MutateTimevalUsecs(n uint64) bool {
	return rcv._tab.MutateUint64Slot(6, n)
}

func (rcv *LogMsg) Uuid(j int) byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetByte(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *LogMsg) UuidLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *LogMsg) UuidBytes() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *LogMsg) MutateUuid(j int, n byte) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateByte(a+flatbuffers.UOffsetT(j*1), n)
	}
	return false
}

func (rcv *LogMsg) LogMsg() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func LogMsgStart(builder *flatbuffers.Builder) {
	builder.StartObject(4)
}
func LogMsgAddTimevalSecs(builder *flatbuffers.Builder, timevalSecs uint64) {
	builder.PrependUint64Slot(0, timevalSecs, 0)
}
func LogMsgAddTimevalUsecs(builder *flatbuffers.Builder, timevalUsecs uint64) {
	builder.PrependUint64Slot(1, timevalUsecs, 0)
}
func LogMsgAddUuid(builder *flatbuffers.Builder, uuid flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(uuid), 0)
}
func LogMsgStartUuidVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func LogMsgAddLogMsg(builder *flatbuffers.Builder, logMsg flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(logMsg), 0)
}
func LogMsgEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type LoadLuaMsgT struct {
	ScriptData string
	ScriptName string
	Metadata   string
}

func LoadLuaMsgPack(builder *flatbuffers.Builder, t *LoadLuaMsgT) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	scriptDataOffset := builder.CreateString(t.ScriptData)
	scriptNameOffset := builder.CreateString(t.ScriptName)
	metadataOffset := builder.CreateString(t.Metadata)
	LoadLuaMsgStart(builder)
	LoadLuaMsgAddScriptData(builder, scriptDataOffset)
	LoadLuaMsgAddScriptName(builder, scriptNameOffset)
	LoadLuaMsgAddMetadata(builder, metadataOffset)
	return LoadLuaMsgEnd(builder)
}

func (rcv *LoadLuaMsg) UnPack() *LoadLuaMsgT {
	if rcv == nil {
		return nil
	}
	t := &LoadLuaMsgT{}
	t.ScriptData = string(rcv.ScriptData())
	t.ScriptName = string(rcv.ScriptName())
	t.Metadata = string(rcv.Metadata())
	return t
}

type LoadLuaMsg struct {
	_tab flatbuffers.Table
}

func GetRootAsLoadLuaMsg(buf []byte, offset flatbuffers.UOffsetT) *LoadLuaMsg {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &LoadLuaMsg{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *LoadLuaMsg) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *LoadLuaMsg) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *LoadLuaMsg) ScriptData() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *LoadLuaMsg) ScriptName() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *LoadLuaMsg) Metadata() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func LoadLuaMsgStart(builder *flatbuffers.Builder) {
	builder.StartObject(3)
}
func LoadLuaMsgAddScriptData(builder *flatbuffers.Builder, scriptData flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(scriptData), 0)
}
func LoadLuaMsgAddScriptName(builder *flatbuffers.Builder, scriptName flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(scriptName), 0)
}
func LoadLuaMsgAddMetadata(builder *flatbuffers.Builder, metadata flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(metadata), 0)
}
func LoadLuaMsgEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type DeleteMsgT struct {
	MetricInfo    *MetricInfoT
	Type          uint64
	DeleteCheck   bool
	Rollups       []uint32
	Endts         uint64
	ConfirmDelete bool
}

func DeleteMsgPack(builder *flatbuffers.Builder, t *DeleteMsgT) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	metricInfoOffset := MetricInfoPack(builder, t.MetricInfo)
	rollupsOffset := flatbuffers.UOffsetT(0)
	if t.Rollups != nil {
		rollupsLength := len(t.Rollups)
		DeleteMsgStartRollupsVector(builder, rollupsLength)
		for j := rollupsLength - 1; j >= 0; j-- {
			builder.PrependUint32(t.Rollups[j])
		}
		rollupsOffset = builder.EndVector(rollupsLength)
	}
	DeleteMsgStart(builder)
	DeleteMsgAddMetricInfo(builder, metricInfoOffset)
	DeleteMsgAddType(builder, t.Type)
	DeleteMsgAddDeleteCheck(builder, t.DeleteCheck)
	DeleteMsgAddRollups(builder, rollupsOffset)
	DeleteMsgAddEndts(builder, t.Endts)
	DeleteMsgAddConfirmDelete(builder, t.ConfirmDelete)
	return DeleteMsgEnd(builder)
}

func (rcv *DeleteMsg) UnPack() *DeleteMsgT {
	if rcv == nil {
		return nil
	}
	t := &DeleteMsgT{}
	t.MetricInfo = rcv.MetricInfo(nil).UnPack()
	t.Type = rcv.Type()
	t.DeleteCheck = rcv.DeleteCheck()
	rollupsLength := rcv.RollupsLength()
	t.Rollups = make([]uint32, rollupsLength)
	for j := 0; j < rollupsLength; j++ {
		t.Rollups[j] = rcv.Rollups(j)
	}
	t.Endts = rcv.Endts()
	t.ConfirmDelete = rcv.ConfirmDelete()
	return t
}

type DeleteMsg struct {
	_tab flatbuffers.Table
}

func GetRootAsDeleteMsg(buf []byte, offset flatbuffers.UOffsetT) *DeleteMsg {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &DeleteMsg{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *DeleteMsg) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *DeleteMsg) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *DeleteMsg) MetricInfo(obj *MetricInfo) *MetricInfo {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(MetricInfo)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *DeleteMsg) Type() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *DeleteMsg) MutateType(n uint64) bool {
	return rcv._tab.MutateUint64Slot(6, n)
}

func (rcv *DeleteMsg) DeleteCheck() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

func (rcv *DeleteMsg) MutateDeleteCheck(n bool) bool {
	return rcv._tab.MutateBoolSlot(8, n)
}

func (rcv *DeleteMsg) Rollups(j int) uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetUint32(a + flatbuffers.UOffsetT(j*4))
	}
	return 0
}

func (rcv *DeleteMsg) RollupsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *DeleteMsg) MutateRollups(j int, n uint32) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateUint32(a+flatbuffers.UOffsetT(j*4), n)
	}
	return false
}

func (rcv *DeleteMsg) Endts() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *DeleteMsg) MutateEndts(n uint64) bool {
	return rcv._tab.MutateUint64Slot(12, n)
}

func (rcv *DeleteMsg) ConfirmDelete() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

func (rcv *DeleteMsg) MutateConfirmDelete(n bool) bool {
	return rcv._tab.MutateBoolSlot(14, n)
}

func DeleteMsgStart(builder *flatbuffers.Builder) {
	builder.StartObject(6)
}
func DeleteMsgAddMetricInfo(builder *flatbuffers.Builder, metricInfo flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(metricInfo), 0)
}
func DeleteMsgAddType(builder *flatbuffers.Builder, type_ uint64) {
	builder.PrependUint64Slot(1, type_, 0)
}
func DeleteMsgAddDeleteCheck(builder *flatbuffers.Builder, deleteCheck bool) {
	builder.PrependBoolSlot(2, deleteCheck, false)
}
func DeleteMsgAddRollups(builder *flatbuffers.Builder, rollups flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(rollups), 0)
}
func DeleteMsgStartRollupsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func DeleteMsgAddEndts(builder *flatbuffers.Builder, endts uint64) {
	builder.PrependUint64Slot(4, endts, 0)
}
func DeleteMsgAddConfirmDelete(builder *flatbuffers.Builder, confirmDelete bool) {
	builder.PrependBoolSlot(5, confirmDelete, false)
}
func DeleteMsgEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

/*type SurrogatePutT struct {
	MetricInfo  *MetricInfoT
	MetricType  byte
	ActivityOil *OilListT
}

func SurrogatePutPack(builder *flatbuffers.Builder, t *SurrogatePutT) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	metricInfoOffset := MetricInfoPack(builder, t.MetricInfo)
	activityOilOffset := OilListPack(builder, t.ActivityOil)
	SurrogatePutStart(builder)
	SurrogatePutAddMetricInfo(builder, metricInfoOffset)
	SurrogatePutAddMetricType(builder, t.MetricType)
	SurrogatePutAddActivityOil(builder, activityOilOffset)
	return SurrogatePutEnd(builder)
}

func (rcv *SurrogatePut) UnPack() *SurrogatePutT {
	if rcv == nil {
		return nil
	}
	t := &SurrogatePutT{}
	t.MetricInfo = rcv.MetricInfo(nil).UnPack()
	t.MetricType = rcv.MetricType()
	t.ActivityOil = rcv.ActivityOil(nil).UnPack()
	return t
}

type SurrogatePut struct {
	_tab flatbuffers.Table
}

func GetRootAsSurrogatePut(buf []byte, offset flatbuffers.UOffsetT) *SurrogatePut {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &SurrogatePut{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *SurrogatePut) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *SurrogatePut) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *SurrogatePut) MetricInfo(obj *MetricInfo) *MetricInfo {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(MetricInfo)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *SurrogatePut) MetricType() byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetByte(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *SurrogatePut) MutateMetricType(n byte) bool {
	return rcv._tab.MutateByteSlot(6, n)
}

func (rcv *SurrogatePut) ActivityOil(obj *OilList) *OilList {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(OilList)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func SurrogatePutStart(builder *flatbuffers.Builder) {
	builder.StartObject(3)
}
func SurrogatePutAddMetricInfo(builder *flatbuffers.Builder, metricInfo flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(metricInfo), 0)
}
func SurrogatePutAddMetricType(builder *flatbuffers.Builder, metricType byte) {
	builder.PrependByteSlot(1, metricType, 0)
}
func SurrogatePutAddActivityOil(builder *flatbuffers.Builder, activityOil flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(activityOil), 0)
}
func SurrogatePutEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type ActivityRebuildT struct {
	MetricInfo *MetricInfoT
}

func ActivityRebuildPack(builder *flatbuffers.Builder, t *ActivityRebuildT) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	metricInfoOffset := MetricInfoPack(builder, t.MetricInfo)
	ActivityRebuildStart(builder)
	ActivityRebuildAddMetricInfo(builder, metricInfoOffset)
	return ActivityRebuildEnd(builder)
}

func (rcv *ActivityRebuild) UnPack() *ActivityRebuildT {
	if rcv == nil {
		return nil
	}
	t := &ActivityRebuildT{}
	t.MetricInfo = rcv.MetricInfo(nil).UnPack()
	return t
}

type ActivityRebuild struct {
	_tab flatbuffers.Table
}

func GetRootAsActivityRebuild(buf []byte, offset flatbuffers.UOffsetT) *ActivityRebuild {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ActivityRebuild{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *ActivityRebuild) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ActivityRebuild) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ActivityRebuild) MetricInfo(obj *MetricInfo) *MetricInfo {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(MetricInfo)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func ActivityRebuildStart(builder *flatbuffers.Builder) {
	builder.StartObject(1)
}
func ActivityRebuildAddMetricInfo(builder *flatbuffers.Builder, metricInfo flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(metricInfo), 0)
}
func ActivityRebuildEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type ReplicationT struct {
	TopoHash  []byte
	Timestamp uint64
	Value     *ReplicationValueT
}

func ReplicationPack(builder *flatbuffers.Builder, t *ReplicationT) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	topoHashOffset := flatbuffers.UOffsetT(0)
	if t.TopoHash != nil {
		topoHashOffset = builder.CreateByteString(t.TopoHash)
	}
	valueOffset := ReplicationValuePack(builder, t.Value)

	ReplicationStart(builder)
	ReplicationAddTopoHash(builder, topoHashOffset)
	ReplicationAddTimestamp(builder, t.Timestamp)
	if t.Value != nil {
		ReplicationAddValueType(builder, t.Value.Type)
	}
	ReplicationAddValue(builder, valueOffset)
	return ReplicationEnd(builder)
}

func (rcv *Replication) UnPack() *ReplicationT {
	if rcv == nil {
		return nil
	}
	t := &ReplicationT{}
	t.TopoHash = rcv.TopoHashBytes()
	t.Timestamp = rcv.Timestamp()
	valueTable := flatbuffers.Table{}
	if rcv.Value(&valueTable) {
		t.Value = ReplicationValueUnPack(rcv.ValueType(), valueTable)
	}
	return t
}

type Replication struct {
	_tab flatbuffers.Table
}

func GetRootAsReplication(buf []byte, offset flatbuffers.UOffsetT) *Replication {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Replication{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Replication) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Replication) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Replication) TopoHash(j int) byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetByte(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *Replication) TopoHashLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Replication) TopoHashBytes() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Replication) MutateTopoHash(j int, n byte) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateByte(a+flatbuffers.UOffsetT(j*1), n)
	}
	return false
}

func (rcv *Replication) Timestamp() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Replication) MutateTimestamp(n uint64) bool {
	return rcv._tab.MutateUint64Slot(6, n)
}

func (rcv *Replication) ValueType() ReplicationValue {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return ReplicationValue(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *Replication) MutateValueType(n ReplicationValue) bool {
	return rcv._tab.MutateByteSlot(8, byte(n))
}

func (rcv *Replication) Value(obj *flatbuffers.Table) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		rcv._tab.Union(obj, o)
		return true
	}
	return false
}

func ReplicationStart(builder *flatbuffers.Builder) {
	builder.StartObject(4)
}
func ReplicationAddTopoHash(builder *flatbuffers.Builder, topoHash flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(topoHash), 0)
}
func ReplicationStartTopoHashVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func ReplicationAddTimestamp(builder *flatbuffers.Builder, timestamp uint64) {
	builder.PrependUint64Slot(1, timestamp, 0)
}
func ReplicationAddValueType(builder *flatbuffers.Builder, valueType ReplicationValue) {
	builder.PrependByteSlot(2, byte(valueType), 0)
}
func ReplicationAddValue(builder *flatbuffers.Builder, value flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(value), 0)
}
func ReplicationEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}*/
